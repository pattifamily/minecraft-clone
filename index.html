<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
        }
        
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            border-radius: 1px;
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            z-index: 100;
        }
        
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 3px solid #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .hotbar-slot.selected {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .hotbar-slot .block-preview {
            width: 36px;
            height: 36px;
            border-radius: 4px;
        }
        
        .hotbar-slot .slot-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 12px;
            color: #aaa;
            font-weight: bold;
        }
        
        #instructions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        #instructions h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #4ade80;
            text-shadow: 3px 3px 0 #22c55e;
        }
        
        #instructions .controls {
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px 30px;
            text-align: left;
            margin: 30px 0;
            font-size: 16px;
        }
        
        #instructions .key {
            background: #333;
            padding: 4px 12px;
            border-radius: 4px;
            border: 2px solid #555;
            color: #fbbf24;
        }
        
        #instructions button {
            font-size: 24px;
            padding: 15px 50px;
            background: #4ade80;
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #instructions button:hover {
            background: #22c55e;
            transform: scale(1.05);
        }
        
        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
            z-index: 100;
            display: none;
        }
        
        #inventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95);
            padding: 20px;
            border-radius: 12px;
            z-index: 150;
            display: none;
            border: 3px solid #555;
        }
        
        #inventory h2 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }
        
        #inventory .inv-grid {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            gap: 8px;
        }
        
        .inv-slot {
            width: 60px;
            height: 60px;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .inv-slot .block-preview {
            width: 44px;
            height: 44px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="crosshair"></div>
    
    <div id="hotbar"></div>
    
    <div id="debug">
        <div>Pos: <span id="debug-pos">0, 0, 0</span></div>
    </div>
    
    <div id="inventory">
        <h2>Inventory</h2>
        <div class="inv-grid"></div>
    </div>
    
    <div id="instructions">
        <h1>⛏️ Minecraft Clone</h1>
        <div class="controls">
            <span class="key">W A S D</span><span>Move</span>
            <span class="key">Mouse</span><span>Look around</span>
            <span class="key">Space</span><span>Jump</span>
            <span class="key">Shift</span><span>Sprint</span>
            <span class="key">Left Click</span><span>Break block</span>
            <span class="key">Right Click</span><span>Place block</span>
            <span class="key">1 - 9</span><span>Select block</span>
            <span class="key">E</span><span>Inventory</span>
            <span class="key">F3</span><span>Debug info</span>
        </div>
        <button id="start-btn">Play Game!</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== GAME CONFIG ====================
        const CONFIG = {
            WORLD_SIZE: 64,
            CHUNK_HEIGHT: 32,
            PLAYER_HEIGHT: 1.8,
            PLAYER_WIDTH: 0.6,
            GRAVITY: 25,
            JUMP_FORCE: 8,
            WALK_SPEED: 5,
            SPRINT_SPEED: 8,
            MOUSE_SENSITIVITY: 0.002,
            REACH_DISTANCE: 5,
            SKY_COLOR: 0x87CEEB,
            FOG_COLOR: 0x87CEEB
        };

        // ==================== BLOCK DEFINITIONS ====================
        const BLOCKS = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            COBBLESTONE: 4,
            OAK_LOG: 5,
            OAK_LEAVES: 6,
            OAK_PLANKS: 7,
            SAND: 8,
            GRAVEL: 9,
            GLASS: 10,
            BRICK: 11,
            BEDROCK: 12
        };

        const BLOCK_COLORS = {
            [BLOCKS.GRASS]: { top: 0x4ade80, side: 0x92400e, bottom: 0x92400e },
            [BLOCKS.DIRT]: 0x92400e,
            [BLOCKS.STONE]: 0x6b7280,
            [BLOCKS.COBBLESTONE]: 0x4b5563,
            [BLOCKS.OAK_LOG]: 0x78350f,
            [BLOCKS.OAK_LEAVES]: 0x166534,
            [BLOCKS.OAK_PLANKS]: 0xa16207,
            [BLOCKS.SAND]: 0xfde047,
            [BLOCKS.GRAVEL]: 0xd4d4d8,
            [BLOCKS.GLASS]: 0xdbeafe,
            [BLOCKS.BRICK]: 0xdc2626,
            [BLOCKS.BEDROCK]: 0x1f2937
        };

        const BLOCK_NAMES = {
            [BLOCKS.GRASS]: 'Grass',
            [BLOCKS.DIRT]: 'Dirt',
            [BLOCKS.STONE]: 'Stone',
            [BLOCKS.COBBLESTONE]: 'Cobblestone',
            [BLOCKS.OAK_LOG]: 'Oak Log',
            [BLOCKS.OAK_LEAVES]: 'Oak Leaves',
            [BLOCKS.OAK_PLANKS]: 'Oak Planks',
            [BLOCKS.SAND]: 'Sand',
            [BLOCKS.GRAVEL]: 'Gravel',
            [BLOCKS.GLASS]: 'Glass',
            [BLOCKS.BRICK]: 'Brick',
            [BLOCKS.BEDROCK]: 'Bedrock'
        };

        // ==================== GLOBAL VARIABLES ====================
        let scene, camera, renderer;
        let world = {};
        let blockMeshes = {};
        let blockGeometry, blockMaterials = {};
        
        let player = {
            position: new THREE.Vector3(CONFIG.WORLD_SIZE / 2, 20, CONFIG.WORLD_SIZE / 2),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            onGround: false,
            selectedBlock: BLOCKS.GRASS
        };

        let keys = {};
        let isPointerLocked = false;
        let raycaster = new THREE.Raycaster();
        let highlightMesh;
        let showDebug = false;

        // ==================== INITIALIZATION ====================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.SKY_COLOR);
            scene.fog = new THREE.Fog(CONFIG.FOG_COLOR, 20, CONFIG.WORLD_SIZE * 0.8);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);
            camera.position.y += CONFIG.PLAYER_HEIGHT * 0.9;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 200;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);

            // Create block geometry and materials
            createBlockMaterials();
            createHighlightMesh();

            // Generate world
            generateTerrain();
            
            // Set spawn position - find a safe spot in the middle of the world
            const spawnX = Math.floor(CONFIG.WORLD_SIZE / 2);
            const spawnZ = Math.floor(CONFIG.WORLD_SIZE / 2);
            let spawnY = getHighestBlock(spawnX, spawnZ);
            
            // Make sure we spawn above ground with extra height
            player.position.set(spawnX + 0.5, spawnY + 2, spawnZ + 0.5);
            
            // Initialize camera position immediately
            camera.position.copy(player.position);
            camera.position.y += CONFIG.PLAYER_HEIGHT * 0.9;

            // Create UI
            createHotbar();

            // Event listeners
            setupEventListeners();

            // Start game loop
            animate();
        }

        function createBlockMaterials() {
            // Create materials for each block
            Object.keys(BLOCK_COLORS).forEach(blockId => {
                const color = BLOCK_COLORS[blockId];
                
                if (typeof color === 'object') {
                    // Grass has different colors for each face
                    blockMaterials[blockId] = [
                        new THREE.MeshLambertMaterial({ color: color.side }), // right
                        new THREE.MeshLambertMaterial({ color: color.side }), // left
                        new THREE.MeshLambertMaterial({ color: color.top }),  // top
                        new THREE.MeshLambertMaterial({ color: color.bottom }), // bottom
                        new THREE.MeshLambertMaterial({ color: color.side }), // front
                        new THREE.MeshLambertMaterial({ color: color.side })  // back
                    ];
                } else {
                    blockMaterials[blockId] = new THREE.MeshLambertMaterial({ 
                        color: color,
                        transparent: blockId === BLOCKS.GLASS,
                        opacity: blockId === BLOCKS.GLASS ? 0.3 : 1
                    });
                }
            });

            blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        }

        function createHighlightMesh() {
            const geometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            highlightMesh = new THREE.Mesh(geometry, material);
            scene.add(highlightMesh);
            highlightMesh.visible = false;
        }

        // ==================== WORLD GENERATION ====================
        function generateTerrain() {
            // Simple noise function
            const noise = (x, z) => {
                const scale = 0.05;
                return Math.sin(x * scale) * Math.cos(z * scale) * 3 +
                       Math.sin(x * scale * 2.5 + 1) * Math.cos(z * scale * 2.5 + 2) * 2;
            };

            for (let x = 0; x < CONFIG.WORLD_SIZE; x++) {
                for (let z = 0; z < CONFIG.WORLD_SIZE; z++) {
                    const height = Math.floor(4 + noise(x, z));
                    
                    for (let y = 0; y <= height; y++) {
                        let block;
                        
                        if (y === 0) {
                            block = BLOCKS.BEDROCK;
                        } else if (y < height - 3) {
                            block = BLOCKS.STONE;
                        } else if (y < height) {
                            block = BLOCKS.DIRT;
                        } else {
                            block = BLOCKS.GRASS;
                        }
                        
                        setBlock(x, y, z, block);
                    }

                    // Generate trees
                    if (Math.random() < 0.02 && x > 5 && x < CONFIG.WORLD_SIZE - 5 && z > 5 && z < CONFIG.WORLD_SIZE - 5) {
                        if (height > 3) {
                            generateTree(x, height + 1, z);
                        }
                    }
                }
            }

            // Create all block meshes
            updateAllBlockMeshes();
        }

        function generateTree(x, y, z) {
            const treeHeight = 4 + Math.floor(Math.random() * 3);
            
            // Trunk
            for (let i = 0; i < treeHeight; i++) {
                setBlock(x, y + i, z, BLOCKS.OAK_LOG);
            }

            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
                for (let lz = -2; lz <= 2; lz++) {
                    for (let ly = 0; ly <= 2; ly++) {
                        if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue;
                        if (ly === 2 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue;
                        
                        const bx = x + lx;
                        const by = y + treeHeight + ly;
                        const bz = z + lz;
                        
                        if (getBlock(bx, by, bz) === BLOCKS.AIR) {
                            setBlock(bx, by, bz, BLOCKS.OAK_LEAVES);
                        }
                    }
                }
            }
        }

        // ==================== BLOCK MANAGEMENT ====================
        function getBlockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        function getBlock(x, y, z) {
            return world[getBlockKey(x, y, z)] || BLOCKS.AIR;
        }

        function setBlock(x, y, z, blockId) {
            if (blockId === BLOCKS.AIR) {
                delete world[getBlockKey(x, y, z)];
            } else {
                world[getBlockKey(x, y, z)] = blockId;
            }
        }

        function getHighestBlock(x, z) {
            for (let y = CONFIG.CHUNK_HEIGHT; y >= 0; y--) {
                if (getBlock(x, y, z) !== BLOCKS.AIR) {
                    return y;
                }
            }
            return 0;
        }

        function updateAllBlockMeshes() {
            // Clear existing meshes
            Object.values(blockMeshes).forEach(mesh => scene.remove(mesh));
            blockMeshes = {};

            // Group blocks by type
            const blocksByType = {};
            
            Object.keys(world).forEach(key => {
                const blockId = world[key];
                if (!blocksByType[blockId]) {
                    blocksByType[blockId] = [];
                }
                const [x, y, z] = key.split(',').map(Number);
                blocksByType[blockId].push({ x, y, z });
            });

            // Create mesh for each block type
            Object.keys(blocksByType).forEach(blockId => {
                const blocks = blocksByType[blockId];
                const mesh = createBlockMesh(blocks, parseInt(blockId));
                blockMeshes[blockId] = mesh;
                scene.add(mesh);
            });
        }

        function createBlockMesh(blocks, blockId) {
            const material = blockMaterials[blockId];
            const mesh = new THREE.InstancedMesh(blockGeometry, material, blocks.length);
            
            const matrix = new THREE.Matrix4();
            blocks.forEach((block, i) => {
                matrix.setPosition(block.x + 0.5, block.y + 0.5, block.z + 0.5);
                mesh.setMatrixAt(i, matrix);
            });
            
            mesh.instanceMatrix.needsUpdate = true;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            return mesh;
        }

        function addBlockMesh(x, y, z, blockId) {
            // For single block additions, we rebuild the type group
            updateAllBlockMeshes();
        }

        function removeBlockMesh(x, y, z, blockId) {
            updateAllBlockMeshes();
        }

        // ==================== PLAYER CONTROLS ====================
        function setupEventListeners() {
            // Pointer lock
            document.getElementById('start-btn').addEventListener('click', () => {
                document.getElementById('instructions').style.display = 'none';
                renderer.domElement.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;
                
                player.rotation.y -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
                player.rotation.x -= e.movementY * CONFIG.MOUSE_SENSITIVITY;
                player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            });

            // Mouse clicks
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked) return;
                
                if (e.button === 0) {
                    breakBlock();
                } else if (e.button === 2) {
                    placeBlock();
                }
            });

            // Prevent context menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                // Number keys for block selection
                if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                    const num = parseInt(e.code.replace('Digit', ''));
                    selectBlock(num);
                }
                
                // Debug
                if (e.code === 'F3') {
                    showDebug = !showDebug;
                    document.getElementById('debug').style.display = showDebug ? 'block' : 'none';
                }
                
                // Inventory
                if (e.code === 'KeyE') {
                    toggleInventory();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function selectBlock(num) {
            const blockIds = Object.keys(BLOCK_COLORS).map(Number).sort((a, b) => a - b);
            if (num >= 1 && num <= blockIds.length) {
                player.selectedBlock = blockIds[num - 1];
                updateHotbarSelection();
            }
        }

        // ==================== BLOCK INTERACTION ====================
        function getTargetBlock() {
            raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
            
            // Check all blocks
            const intersects = [];
            Object.keys(world).forEach(key => {
                const [x, y, z] = key.split(',').map(Number);
                const blockId = world[key];
                
                const box = new THREE.Box3(
                    new THREE.Vector3(x, y, z),
                    new THREE.Vector3(x + 1, y + 1, z + 1)
                );
                
                const intersect = raycaster.ray.intersectBox(box);
                if (intersect) {
                    intersects.push({
                        point: intersect,
                        distance: camera.position.distanceTo(intersect),
                        blockPos: { x, y, z, id: blockId }
                    });
                }
            });
            
            if (intersects.length === 0) return null;
            
            // Sort by distance and filter by reach
            intersects.sort((a, b) => a.distance - b.distance);
            return intersects.find(i => i.distance <= CONFIG.REACH_DISTANCE);
        }

        function breakBlock() {
            const target = getTargetBlock();
            if (!target) return;
            
            const { x, y, z, id } = target.blockPos;
            
            if (id === BLOCKS.BEDROCK) return; // Can't break bedrock
            
            setBlock(x, y, z, BLOCKS.AIR);
            removeBlockMesh(x, y, z, id);
        }

        function placeBlock() {
            const target = getTargetBlock();
            if (!target) return;
            
            const { x, y, z } = target.blockPos;
            const direction = camera.getWorldDirection(new THREE.Vector3());
            
            // Determine which face we're looking at
            const hitPoint = target.point;
            const faceX = Math.abs(direction.x) > 0.5 ? Math.sign(direction.x) : 0;
            const faceY = Math.abs(direction.y) > 0.5 ? Math.sign(direction.y) : 0;
            const faceZ = Math.abs(direction.z) > 0.5 ? Math.sign(direction.z) : 0;
            
            const newX = x + faceX;
            const newY = y + faceY;
            const newZ = z + faceZ;
            
            // Check if position is valid (not inside player)
            const playerBox = new THREE.Box3(
                player.position.clone().add(new THREE.Vector3(-CONFIG.PLAYER_WIDTH/2, 0, -CONFIG.PLAYER_WIDTH/2)),
                player.position.clone().add(new THREE.Vector3(CONFIG.PLAYER_WIDTH/2, CONFIG.PLAYER_HEIGHT, CONFIG.PLAYER_WIDTH/2))
            );
            
            const newBlockBox = new THREE.Box3(
                new THREE.Vector3(newX, newY, newZ),
                new THREE.Vector3(newX + 1, newY + 1, newZ + 1)
            );
            
            if (playerBox.intersectsBox(newBlockBox)) return;
            
            // Check bounds
            if (newX < 0 || newX >= CONFIG.WORLD_SIZE || 
                newY < 0 || newY >= CONFIG.CHUNK_HEIGHT ||
                newZ < 0 || newZ >= CONFIG.WORLD_SIZE) return;
            
            setBlock(newX, newY, newZ, player.selectedBlock);
            addBlockMesh(newX, newY, newZ, player.selectedBlock);
        }

        // ==================== PHYSICS & COLLISION ====================
        function updatePlayer(deltaTime) {
            if (!isPointerLocked) return;

            // Calculate movement direction
            const moveSpeed = keys['ShiftLeft'] ? CONFIG.SPRINT_SPEED : CONFIG.WALK_SPEED;
            const moveDir = new THREE.Vector3();
            
            if (keys['KeyW']) moveDir.z -= 1;
            if (keys['KeyS']) moveDir.z += 1;
            if (keys['KeyA']) moveDir.x -= 1;
            if (keys['KeyD']) moveDir.x += 1;
            
            // Apply rotation to movement direction
            moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            moveDir.normalize();
            
            // Apply movement
            player.velocity.x = moveDir.x * moveSpeed;
            player.velocity.z = moveDir.z * moveSpeed;
            
            // Jump
            if (keys['Space'] && player.onGround) {
                player.velocity.y = CONFIG.JUMP_FORCE;
                player.onGround = false;
            }
            
            // Apply gravity
            player.velocity.y -= CONFIG.GRAVITY * deltaTime;
            
            // Move with collision detection
            const newPos = player.position.clone();
            
            // X movement
            newPos.x += player.velocity.x * deltaTime;
            if (checkCollision(newPos)) {
                newPos.x = player.position.x;
                player.velocity.x = 0;
            }
            
            // Z movement
            newPos.z += player.velocity.z * deltaTime;
            if (checkCollision(newPos)) {
                newPos.z = player.position.z;
                player.velocity.z = 0;
            }
            
            // Y movement
            newPos.y += player.velocity.y * deltaTime;
            if (checkCollision(newPos)) {
                if (player.velocity.y < 0) {
                    player.onGround = true;
                    // Snap to top of block
                    newPos.y = Math.floor(newPos.y) + 0.001;
                }
                player.velocity.y = 0;
            } else {
                player.onGround = false;
            }
            
            // Keep in bounds
            newPos.x = Math.max(0, Math.min(CONFIG.WORLD_SIZE - 0.1, newPos.x));
            newPos.z = Math.max(0, Math.min(CONFIG.WORLD_SIZE - 0.1, newPos.z));
            
            // Prevent falling through the world - find ground below
            if (newPos.y < 1) {
                const groundY = getHighestBlock(Math.floor(newPos.x), Math.floor(newPos.z));
                newPos.y = groundY + CONFIG.PLAYER_HEIGHT;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            player.position.copy(newPos);
            
            // Update camera
            camera.position.copy(player.position);
            camera.position.y += CONFIG.PLAYER_HEIGHT * 0.9;
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation.y;
            camera.rotation.x = player.rotation.x;
            
            // Update debug
            if (showDebug) {
                document.getElementById('debug-pos').textContent = 
                    `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
            }
        }

        function checkCollision(pos) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(
                    pos.x - CONFIG.PLAYER_WIDTH / 2,
                    pos.y,
                    pos.z - CONFIG.PLAYER_WIDTH / 2
                ),
                new THREE.Vector3(
                    pos.x + CONFIG.PLAYER_WIDTH / 2,
                    pos.y + CONFIG.PLAYER_HEIGHT,
                    pos.z + CONFIG.PLAYER_WIDTH / 2
                )
            );
            
            // Check all nearby blocks
            const minX = Math.floor(pos.x - CONFIG.PLAYER_WIDTH);
            const maxX = Math.ceil(pos.x + CONFIG.PLAYER_WIDTH);
            const minY = Math.floor(pos.y);
            const maxY = Math.ceil(pos.y + CONFIG.PLAYER_HEIGHT);
            const minZ = Math.floor(pos.z - CONFIG.PLAYER_WIDTH);
            const maxZ = Math.ceil(pos.z + CONFIG.PLAYER_WIDTH);
            
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        if (getBlock(x, y, z) !== BLOCKS.AIR) {
                            const blockBox = new THREE.Box3(
                                new THREE.Vector3(x, y, z),
                                new THREE.Vector3(x + 1, y + 1, z + 1)
                            );
                            if (playerBox.intersectsBox(blockBox)) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            return false;
        }

        // ==================== UI ====================
        function createHotbar() {
            const hotbar = document.getElementById('hotbar');
            const blockIds = Object.keys(BLOCK_COLORS).map(Number).sort((a, b) => a - b);
            
            blockIds.forEach((blockId, index) => {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (blockId === player.selectedBlock ? ' selected' : '');
                slot.dataset.blockId = blockId;
                
                const number = document.createElement('span');
                number.className = 'slot-number';
                number.textContent = index + 1;
                
                const preview = document.createElement('div');
                preview.className = 'block-preview';
                preview.style.background = getBlockColorStyle(blockId);
                
                slot.appendChild(number);
                slot.appendChild(preview);
                hotbar.appendChild(slot);
            });
            
            // Create inventory
            createInventory();
        }

        function getBlockColorStyle(blockId) {
            const color = BLOCK_COLORS[blockId];
            if (typeof color === 'object') {
                return `linear-gradient(135deg, ${'#' + color.top.toString(16).padStart(6, '0')} 50%, 
                        ${'#' + color.side.toString(16).padStart(6, '0')} 50%)`;
            }
            return '#' + color.toString(16).padStart(6, '0');
        }

        function updateHotbarSelection() {
            document.querySelectorAll('.hotbar-slot').forEach(slot => {
                slot.classList.toggle('selected', 
                    parseInt(slot.dataset.blockId) === player.selectedBlock);
            });
        }

        function createInventory() {
            const invGrid = document.querySelector('#inventory .inv-grid');
            const blockIds = Object.keys(BLOCK_COLORS).map(Number).sort((a, b) => a - b);
            
            blockIds.forEach(blockId => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                slot.title = BLOCK_NAMES[blockId];
                
                const preview = document.createElement('div');
                preview.className = 'block-preview';
                preview.style.background = getBlockColorStyle(blockId);
                preview.style.width = '44px';
                preview.style.height = '44px';
                
                slot.appendChild(preview);
                invGrid.appendChild(slot);
            });
        }

        function toggleInventory() {
            const inv = document.getElementById('inventory');
            inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
        }

        // ==================== HIGHLIGHT ====================
        function updateHighlight() {
            const target = getTargetBlock();
            
            if (target && target.distance <= CONFIG.REACH_DISTANCE) {
                const { x, y, z } = target.blockPos;
                highlightMesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                highlightMesh.visible = true;
            } else {
                highlightMesh.visible = false;
            }
        }

        // ==================== GAME LOOP ====================
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            updatePlayer(deltaTime);
            updateHighlight();
            
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
